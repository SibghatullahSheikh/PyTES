#!/usr/bin/env python

import pyfits
from numpy import *
from pytes import *
import matplotlib
matplotlib.use( 'Agg' )
from pylab import figure, plot, errorbar, hist, xlim, loglog, xlabel, ylabel, savefig

def main(pulse, noise, cutoff=None, max_shift=10, ka_min=80, kb_min=40, sigma=2, shift=False, session="Unnamed"):
    
    print "Session: %s" % session
    
    # Open fits file and get pulse/noise data
    phl = pyfits.open(pulse)
    p = phl[1].data.field(1).copy()
    dtp = phl[1].header['THSCL2']
    tp = arange(p.shape[-1]) * dtp
    
    phl.close()
    
    nhl = pyfits.open(noise)
    n = nhl[1].data.field(1).copy()
    dtn = phl[1].header['THSCL2']
    tn = arange(n.shape[-1]) * dtn
    nhl.close()
    
    # Plot averaged pulse
    figure()
    plot(tp, Filter.average_pulse(p, max_shift=max_shift))
    xlabel('Time\quad(s)')
    ylabel('Averaged Pulse\quad(V)')
    savefig('%s-averagepulse.pdf' % session)
    
    # Plot noise spectrum
    nspec = sqrt(Filter.average_noise(n)*(dtn*n.shape[-1]))
    figure()
    plot(arange(len(nspec))*(dtn*n.shape[-1])**-1, nspec)
    loglog()
    xlabel('Frequency\quad(Hz)')
    ylabel('Noise\quad(V/$\sqrt{\mathrm{Hz}}$)')
    savefig('%s-noise.pdf' % session)
    
    # Generate template
    t, sn = Filter.generate_template(p, n, cutoff=cutoff, max_shift=max_shift)
    
    # Plot template
    figure()
    plot(tp, t)
    xlabel('Time\quad(s)')
    ylabel('Template\quad(A.U.)')
    savefig('%s-template.pdf' % session)
    
    # Plot S/N ratio
    figure()
    plot(arange(len(sn))*(dtp*p.shape[-1])**-1, sn*sqrt(dtp*p.shape[-1]))
    loglog()
    xlabel('Frequency\quad(Hz)')
    ylabel('S/N\quad(/$\sqrt{\mathrm{Hz}}$)')
    savefig('%s-sn.pdf' % session)
    
    # Calculate baseline resolution
    print "Baseline resolution for 5.9 keV: %.2f eV" % Analysis.baseline(sn)
    
    # Perform optimal filtering
    pha = Filter.optimal_filter(p, t, max_shift=max_shift)
    
    # Offset correction
    offset = Filter.offset(p)
    oc_pha = Analysis.offset_correction(pha, offset, sigma=2)
    
    # Linearity correction
    lc_pha = Analysis.linearity_correction(oc_pha, sigma=2)
    
    # Spectrum
    figure()
    hist(lc_pha/1e3, bins=4096, histtype='stepfilled', color='y')
    xlim(0, 7)
    xlabel('Energy\quad(keV)')
    ylabel('Count')
    savefig('%s-spec.pdf' % session)
    
    # Fitting
    
    ## MnKa
    mnka = Analysis.ka(lc_pha, sigma=sigma)
    fit(mnka, ka_min, "MnKa", shift, session)

    ## MnKb
    mnkb = Analysis.kb(lc_pha, sigma=sigma)
    fit(mnkb, kb_min, "MnKb", shift, session)
    
    return 0

def fit(data, min, line, shift, session):
    # Draw histogram
    figure()
    n, bins = Analysis.histogram(data)
    gn, gbins = Analysis.group_bin(n, bins, min=min)
    ngn = gn/(diff(gbins)*1e3)
    ngn_sigma = sqrt(gn)/(diff(gbins)*1e3)
    cbins = (gbins[1:]+gbins[:-1])/2

    errorbar(cbins, ngn, yerr=ngn_sigma, xerr=diff(gbins)/2, capsize=0, ecolor='k', fmt=None)

    # Fit
    (dE, dE_error, A, A_error, width, width_error), chi_squared, dof = \
            Analysis.fit(data, min=min, line=line, shift=shift)

    # Draw fitting result
    E = linspace(bins.min(), bins.max(), 1000)
    model = A*Analysis.line_model(E, dE, width, line=line, shift=shift, full=True)
    plot(E, model[0], 'r-')
    for m in model[1:]:
        plot(E, m, 'b--')

    xlabel('Energy\quad(eV)')
    ylabel('Normalized Count\quad(count/keV)')

    savefig("%s-%s.pdf" % (session, line))

    print "%s: %.2f +/- %.2f eV @ Ec%+.2f eV (Red. chi^2 = %.1f/%d = %.2f)" \
            % (line, width, width_error, dE, chi_squared, dof, chi_squared/dof)

def usage(prog, ka_min, kb_min, sigma, session):
    print """Usage: %s [options] pulse.fits noise.fits

Options:
    -c cutoff
        Cut-off bin for template generation (Default: no cut-off)
    -a min
        Desired minimum photons to group bins for MnKa spectrum (Default: %d)
    -b min
        Desired minimum photons to group bins for MnKb spectrum (Default: %d)
    -s sigmas
        Sigmas for median filter (Default: %d)
    --shift
        Treat dE as energy shift instead of scaling
    --session name
        Session name used for output files (Default: %s)
    -h
        Show this usage.""" % (prog, ka_min, kb_min, sigma, session)

if __name__ == '__main__':
    
    import sys, getopt
    
    opts, params = getopt.getopt(sys.argv[1:], 'h?a:b:c:s:', ['shift', 'session=', 'help'])
    
    # Initialize
    cutoff = None
    ka_min = 80
    kb_min = 40
    sigma = 3
    shift = False
    session = "Unnamed"
    
    for o, a in opts:
        if o == "-c":
            cutoff = int(a)
        if o == "-a":
            ka_min = int(a)
        if o == "-b":
            kb_min = int(a)
        if o == "-s":
            sigma = float(a)
        if o == "--shift":
            shift = True
        if o == "--session":
            session = a
        if o in ("-h", "-?", "--help"):
            usage(sys.argv[0], ka_min, kb_min, sigma, session)
            exit()

    try:
        pulse, noise = params
    except:
        usage(sys.argv[0], ka_min, kb_min, sigma, session)
        exit()
    
    main(pulse, noise, cutoff=cutoff, ka_min=ka_min, kb_min=kb_min, shift=shift, sigma=sigma, session=session)